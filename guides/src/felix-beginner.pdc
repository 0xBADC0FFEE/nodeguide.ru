# Руководство для начинающих по Node.js от Felix'a

В интернете сейчас много информации про node.js, но учитывая скорость, с которой
идет разработка, достаточно тяжело найти актуальную информацию о том, как начать 
с ним работать. Это руководство ставит перед собой именно такую цель - оставаться 
актуальным для последней стабильной версии node.js.

Сейчас руководство соответствует последним изменениям в версии node 0.4.x., которая
является стабильной веткой.

## Изучение JavaScript

Предполагается, что читатель уже знаком с JavaScript. Если нет, то можно начать с чтения 
[Eloquent JavaScript][eloquentjs], свободно распространяемой книги от [Marijn Haverbeke][marijn].

[eloquentjs]: http://eloquentjavascript.net/
[marijn]: http://twitter.com/marijnjh

## Hello World

Этот пример продемонстрирует как установить node.js, включая создание простого
http сервера.

### Установка node.js

Прежде всего: для того, чтобы использовать node.js необходимо иметь под рукой 
работающую \*nix - подобную операционную систему. Рекомендуется Linux или OSX, 
но так же могут подойти FreeBSD или cygwin (под windows). В настоящее время ведутся 
работы над портированием node.js под windows, но пока они не доведены до стабильного
состояния.

Наиболее распространенный подход для установки node.js является его компиляция 
из исходных кодов. Существуют так же различные пакеты для пакетных менеджеров, 
но учитывая то, как часто они обновляются и то, как их обновление может различаться,
рекомендуется установка из исходных кодов.

Получить последние исходные коды можно на сайте [nodejs.org][nodejs]. Для получения
и установки версии 0.4.5 необходимо выполнить следующие команды:

[nodejs]: http://nodejs.org/

~~~ {.shell}
$ wget http://nodejs.org/dist/node-v0.4.5.tar.gz
$ tar -xzf node-v0.4.5.tar.gz
$ cd node-v0.4.5.tar.gz
$ ./configure
$ sudo make install
~~~

Node.js не имеет внешних зависимостей, кроме python, который используется при сборке.
В OSX необходимо установить XCode перед началом установки. В Ubuntu же необходимо 
выполнить:

~~~ {.shell}
$ apt-get -y install build-essential
~~~

### Интерактивная оболочка node.js

Если установка прошла без ошибок, то станет доступен вызов интерактивной оболочки
node.js, например:

~~~ {.shell}
$ node
> console.log('Hello World');
Hello World
~~~

Интерактивная оболочка (или [REPL][REPL], [REPL-ru][REPLRU]) удобна для тестирования 
простых однострочных примеров. Кроме того, она может быть [внедрена][repldocs] в любое 
node.js приложение. Для того, чтобы выйти из интерактивной оболочки, необходимо просто 
нажать Ctrl + C.

Оболочка (REPL) обладает множеством удобств, основным среди которых является автодополнение.

[repldocs]: http://nodejs.org/docs/v0.4.5/api/repl.html#repl.start
[REPL]: http://en.wikipedia.org/wiki/REPL
[REPLRU]: http://ru.wikipedia.org/wiki/REPL

### Первая программа

Для того, чтобы создать приложение для node.js, необходимо всего лишь создать
новый файл с расширением '.js'. Например, можно создать файл 'hello_world.js'
со следующим содержимым:

~~~ {.javascript}
console.log('Hello World');
~~~

После того, как файл сохранен, его можно запустить на выполнение из терминала/консоли
следующим образом:

~~~ {.shell}
$ node hello.js
Hello World
~~~

### hello world http-сервер

В наше время вывод на терминал 'hello world' не сильно впечатляет. Необходимо идти 
дальше и написать программу, которая отдает 'hello world' по http. Для этого необходимо 
создать файл 'hello_http.js' и поместить в него следующий код:

~~~ {.javascript}
var http = require('http');

var server = http.createServer(function(req, res) {
  res.writeHead(200);
  res.end('Hello Http');
});
server.listen(8080);
~~~

Для того, чтобы запустить это приложение, необходимо выполнить в терминале/консоле:

~~~ {.shell}
$ node hello_http.js
~~~

Первое, что бросается в глаза - это то, что эта прогарамма, в отличие от первой,
не прекращается сразу. Это происходит в силу того, что node.js приложение будет всегда 
исполняться, пока не станет ясно, что никакие дальнейшие события не возможны. В этом 
случае запущенный http сервер - это источник событий, которые будут обеспечивать 
работу node.js приложения.

Чтобы проверить работу сервера достаточно открыть новую закладку в web-браузере и 
перейти по следующему адресу: [http://localhost:8080/][localhost]. Как и
ожидалось, ответом будет: 'Hello Http'.

В качестве альтернативы, можно воспользоваться терминалом/консолью и используя [curl][curl] 
протестировать работу сервера:

[curl]: http://ru.wikipedia.org/wiki/CURL

~~~ {.shell}
$ curl localhost:8080
Hello Http
~~~

Теперь необходимо по-ближе посмотреть на код созданной программы. В первой строке
подключается [http][httpdoc] модуль ядра и присваивается переменной `http`. О 
модульной системе будет рассказано более подробно в следующем разделе.

В следующей строке создается переменная `server` которой присваивается результат
вызова метода [http.createServer][createServerdoc]. Аргументом при вызове этого 
метода является [замыкание][closure], которое будет вызываться каждый раз, когда 
приходит http-запрос.

И в конце вызывается метод [server.listen(8080)][listendoc], который указатывает node.js
на каком порту требуется работа сервера. Если необходимо запустить сервер на 80-ом 
порту, то программу необходимо запускать с правами [супер пользователя][rootdoc].

[httpdoc]: http://nodejs.org/docs/v0.4.5/api/http.html
[createServerdoc]: http://nodejs.org/docs/v0.4.5/api/http.html#http.createServer
[listendoc]: http://nodejs.org/docs/v0.4.5/api/http.html#server.listen
[closure]: http://ru.wikipedia.org/wiki/Замыкание_(программирование) 
[rootdoc]: http://ru.wikipedia.org/wiki/Root_(суперпользователь) 

Далее, когда в браузере идет обращение к адресу [localhost:8080][localhost], 
вызывается замыкание с параметрами [req][reqdoc] и [res][resdoc]. Req - это поток,
доступный для чтения, который содержит данные каждого http-запроса (например, 
подтверждение формы или загрузка файла). Res - это поток, доступный для записи,
который используется для отправки данных обратно клиенту. В примере, отсылается 
заголовок 200 OK, а так же тело ответа 'Hello Http'.

[localhost]: http://localhost:8080/
[reqdoc]: http://nodejs.org/docs/v0.4.5/api/http.html#http.ServerRequest
[resdoc]: http://nodejs.org/docs/v0.4.5/api/http.html#http.ServerResponse

## Модульная система

Для организации программ в виде отдельных файлов, node.js предлагает к использованию
модульную систему.

Для демонстрации подхода создадим файл 'main.js' со следующим содержимым:

~~~ {.javascript}
var hello = require('./hello');
hello.world();
~~~

Не трудно догадаться, что `require('./hello')` используется для импорта данных из
отдельного JavaScript файла. './' означает, что файл находится в той же директории,
что и и сам файл 'main.js'. Так же следует обратить внимание, что не требуется 
указывать расширение файла, так как '.js' подставляется по умолчанию.

Далее, необходимо создать файл 'hello.js' со следующим содержимым:

~~~ {.javascript}
exports.world = function() {
  console.log('Hello World');
}
~~~

Тут следует обратить внимание на то, что происходит присваивание свойству 'world'
объекта 'exports'. Таким образом объявляется, что модуль 'hello.js' экспортирует 
во вне функцию 'world'. Объект 'exports' доступен в любом модуле и возвращается при 
каждом вызове функции `require` при подключении модуля. При запуске 'main.js'
вывод будет следующим:

~~~ {.shell}
$ node main.js
Hello World
~~~

Будет не лишним упомянуть, что зачастую объект 'exports' переопределяется следующим 
образом:

~~~ {.javascript}
module.exports = function() {
  // ...
}
~~~

Как и ожидается, такое переопределение будет причиной того, что функция `require`
будет возвращать функцию. Такой подход полезен при [объекто ориентированном программировании][oopguide],
где каждый файл экспортирует конструктор одного класса.

[oopguide]: /felix/object_oriented_programming/

Следующая вещь, которую надо понимать при работе с модульной системой, это то, 
как система работает с вызовами 'require', которые не включают относительную 
подсказку о метоположении подключаемого файла. Например:

~~~ {.javascript}
var http = require('http');
~~~

Первое, что сделает node.js - это определит, есть ли модуль ядра с именем http.
Если есть, то вернет соответствующую директорию. Но что будет при работе с модулями
не относящимися к ядру, как например 'mysql'?

~~~ {.javascript}
var mysql = require('mysql');
~~~

В этом случае node.js будет искать в каждой директории, начиная с одного из текущих
файлов, и проверять, есть ли директория с именем 'node_modules'. Если такая директория
найдена, node.js начнет поиск в ней файла с именем 'mysql.js'. Если подходящих файлов 
не найдено и достигнут корень файловой системы ('/') node.js сдается и выбрасывает
исключение.

В настоящий момент node.js учитывает дополнительный изменяемый список альтернативных
директорий для импорта. Список доступен через массив `require.paths`. Однако идет
активное обсуждение на тему удаления этой возможности, так что лучше пока не 
использовать ее.

И наконец, node.js учитывает файл 'index.js', в котором описывается главный
файл импорта для директории. Таким образом, если встретится вызов `require('./foo')`,
то node.js будет пробовать искать файлы и 'foo.js' и 'foo/index.js'.

## Использование EventEmitters

Node.js реализует [шаблон проектирования][pattern] [наблюдатель][observerpattern] 
([рус][observerpatternru]) используя класс EventEmitter. Всегда, когда естЬ объект, 
который является источником событий, node.js наследует класс этого объекта от класса 
EventEmitter.

Использовать EventEmitter и его наследников довольно просто. Необходимо лишь вызвать 
метод 'on()' у объекта, генерирующего события, и передать в качестве параметров имя 
события и функцию обратного вызова. Например:

[observerpattern]: http://en.wikipedia.org/wiki/Observer_pattern
[observerpatternru]: http://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования) 
[pattern]: http://ru.wikipedia.org/wiki/Шаблон_проектирования

~~~ {.javascript}
var data = '';
req
  .on('data', function(chunk) {
    data += chunk;
  })
  .on('end', function() {
    console.log('POST data: %s', data);
  })
~~~

Как видно, функция [on()][ondoc] возвращает ссылку на объект, которому она принадлежит,
что позволяет связывать в цепочки вызовов несколько прослушивателей событий.

Если интересует только первое возникновение события, то вместо [on()][ondoc] можно использовать 
функцию [once()][oncedoc].

Наконец, можно удалить возможность прослушивания событий с помощью функции [removeListener]
[removeListenerdoc]. Следует обратить внимание, что аргументами в этой функции являются
ссылки на функции обратного вызова, которые необходимо удалить, а не имена событий:

[removeListenerdoc]: http://nodejs.org/docs/v0.4.5/api/all.html#emitter.removeListener
[ondoc]: http://nodejs.org/docs/v0.4.5/api/all.html#emitter.on
[oncedoc]: http://nodejs.org/docs/v0.4.5/api/all.html#emitter.once


~~~ {.javascript}
var onData = function(chunk) {
  console.log(chunk);
  req.removeListener(onData);
}

req.on('data', onData);
~~~

Этот пример идентичен случаю использования метода [once()][oncedoc].

## Что дальше ?

Теперь у вас есть базовые знания о node.js и сейчас лучше попробовать написать
самостоятельно несколько небольших программ. Лучшее место для начала - это 
[документация по API node.js][nodeapidocs].

[nodeapidocs]: http://nodejs.org/docs/v0.4.5/api/

## Отладка приложений node.js

Существует много способов отладки node.js приложений. Лично я предпочитаю отлаживаться
как можно меньше и следовать максимально точно [руководству по разработке через 
тестирование][tddguide].

Однако, если случится ситуация, когда будет необходимо локализовать необычную
ошибку в приложении, можно воспользоваться одним из указанных способов.

[tddguide]: test_driven_development.html

### Использование console.log()

Самый просто способ понять проблему - это исследовать объекты с помощью
console.log(). Объекты можно передавать в качестве параметров:

~~~ {.javascript}
var foo = {bar: 'foobar'};
console.log(foo);
~~~

Или же можно использовать sprintf-подобные возможности для форматирования
отладочных сообщений:

~~~ {.javascript}
var foo = {bar: 'foobar'};
console.log('Hello %s, this is my object: %j', 'World', foo);
~~~

### Использование отладчика node.js

Если console.log() чем-то не устраивает или есть вероятность, что текущая проблема 
может быть решена быстрее с помощью точек останова, то наиболее подходящим вариантом
будет встроенный node.js отладчик. Отладчик вызывается легко:

~~~ {.shell}
$ node.js debug my_file.js
~~~

*Work in progress, please come back later ...*

### Использование WebKit Inspector

*Work in progress, please come back later ...*

## Фреймворки

Новичку с node.js вряд ли захочется изобретать колесо, когда потребуется разобрать
POST-запрос, маршрутизировать URL или сформировать представление. В этих случаях 
с большой долей вероятности захочется использовать один из популярных веб-фреймворков.
Данный раздел дает беглый обзор основных их них и мое отношение к ним.

### Express

На текущий момент [express][express] - наиболее подходящий фреймворк для
большинства node.js разработчиков. Он относительно зрелый и включает [connect][connect]
(тонкий каркас) средний слой. Поддерживает такие возможности, как маршрутизация, 
конфигурация, шаблонный движок, разбор POST запросов и многое другое.

В то время, как express уже достаточно цельный фреймворк, он используется в гораздо
меньших масштабах по сравнению с такими аналогами, как Rails, CakePHP или Django.
Express наболее сопоставим с таким инструментом, как Sinatra и, к сожалению, пока 
не сделал больших усилий для того, чтобы уйти от Ruby корней в сторону чего-то более 
естественного для JavaScript. Так или иначе, его использование гораздо проще и быстрее,
чем создание своего собственного фреймворка и в настоящий момент это наиболее достойный
выбор.

[express]: http://expressjs.com/
[connect]: https://github.com/senchalabs/connect

### fab.js

Думаете, что знаете JavaScript? Подумайте еще раз. Разработчики [fab.js][fabjs], 
вдохновленные цепочками jQuery, выбрали очень необычный подход. Каждая функция 
возвращает функцию, устраняя необходмиость в именах методов вообще. Тем самым
формируется код, напоминающий Lisp.

На данный момент, я не считаю, что fab.js готов к промышленной разработке. Но
если вы все еще изучаете мир node.js, то вам абсолютно необходимо эту библиотеку
как минимум один раз. Если альтернативы нет, то fab.js откроет мир, в котором 
JavaScript не копирует решения Ruby, Python или PHP при создании веб-фреймворков
и может развиваться уникальным образом. 

[fabjs]: http://fabjs.org/

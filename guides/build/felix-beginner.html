<div id="&#1088;&#1091;&#1082;&#1086;&#1074;&#1086;&#1076;&#1089;&#1090;&#1074;&#1086;-&#1076;&#1083;&#1103;-&#1085;&#1072;&#1095;&#1080;&#1085;&#1072;&#1102;&#1097;&#1080;&#1093;-&#1087;&#1086;-node.js-&#1086;&#1090;-felixa"
><h1
  ><a href="#TOC"
    >Руководство для начинающих по Node.js от Felix'a</a
    ></h1
  ><p
  >В интернете сейчас много информации про node.js, но учитывая скорость, с которой идет разработка, достаточно тяжело найти актуальную информацию о том, как начать с ним работать. Это руководство ставит перед собой именно такую цель - оставаться актуальным для последней стабильной версии node.js.</p
  ><p
  >Сейчас руководство соответствует последним изменениям в версии node 0.4.x., которая является стабильной веткой.</p
  ><div id="&#1080;&#1079;&#1091;&#1095;&#1077;&#1085;&#1080;&#1077;-javascript"
  ><h2
    ><a href="#TOC"
      >Изучение JavaScript</a
      ></h2
    ><p
    >Предполагается, что читатель уже знаком с JavaScript. Если нет, то можно начать с чтения <a href="http://eloquentjavascript.net/"
      >Eloquent JavaScript</a
      >, свободно распространяемой книги от <a href="http://twitter.com/marijnjh"
      >Marijn Haverbeke</a
      >.</p
    ></div
  ><div id="hello-world"
  ><h2
    ><a href="#TOC"
      >Hello World</a
      ></h2
    ><p
    >Этот пример продемонстрирует как установить node.js, включая создание простого http сервера.</p
    ><div id="&#1091;&#1089;&#1090;&#1072;&#1085;&#1086;&#1074;&#1082;&#1072;-node.js"
    ><h3
      ><a href="#TOC"
	>Установка node.js</a
	></h3
      ><p
      >Прежде всего: для того, чтобы использовать node.js необходимо иметь под рукой работающую *nix - подобную операционную систему. Рекомендуется Linux или OSX, но так же могут подойти FreeBSD или cygwin (под windows). В настоящее время ведутся работы над портированием node.js под windows, но пока они не доведены до стабильного состояния.</p
      ><p
      >Наиболее распространенный подход для установки node.js является его компиляция из исходных кодов. Существуют так же различные пакеты для пакетных менеджеров, но учитывая то, как часто они обновляются и то, как их обновление может различаться, рекомендуется установка из исходных кодов.</p
      ><p
      >Получить последние исходные коды можно на сайте <a href="http://nodejs.org/"
	>nodejs.org</a
	>. Для получения и установки версии 0.4.5 необходимо выполнить следующие команды:</p
      ><pre class="shell"
      ><code
	>$ wget http://nodejs.org/dist/node-v0.4.5.tar.gz
$ tar -xzf node-v0.4.5.tar.gz
$ cd node-v0.4.5.tar.gz
$ ./configure
$ sudo make install
</code
	></pre
      ><p
      >Node.js не имеет внешних зависимостей, кроме python, который используется при сборке. В OSX необходимо установить XCode перед началом установки. В Ubuntu же необходимо выполнить:</p
      ><pre class="shell"
      ><code
	>$ apt-get -y install build-essential
</code
	></pre
      ></div
    ><div id="&#1080;&#1085;&#1090;&#1077;&#1088;&#1072;&#1082;&#1090;&#1080;&#1074;&#1085;&#1072;&#1103;-&#1086;&#1073;&#1086;&#1083;&#1086;&#1095;&#1082;&#1072;-node.js"
    ><h3
      ><a href="#TOC"
	>Интерактивная оболочка node.js</a
	></h3
      ><p
      >Если установка прошла без ошибок, то станет доступен вызов интерактивной оболочки node.js, например:</p
      ><pre class="shell"
      ><code
	>$ node
&gt; console.log('Hello World');
Hello World
</code
	></pre
      ><p
      >Интерактивная оболочка (или <a href="http://en.wikipedia.org/wiki/REPL"
	>REPL</a
	>, <a href="http://ru.wikipedia.org/wiki/REPL"
	>REPL-ru</a
	>) удобна для тестирования простых однострочных примеров. Кроме того, она может быть <a href="http://nodejs.org/docs/v0.4.5/api/repl.html#repl.start"
	>внедрена</a
	> в любое node.js приложение. Для того, чтобы выйти из интерактивной оболочки, необходимо просто нажать Ctrl + C.</p
      ><p
      >Оболочка (REPL) обладает множеством удобств, основным среди которых является автодополнение.</p
      ></div
    ><div id="&#1087;&#1077;&#1088;&#1074;&#1072;&#1103;-&#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1072;"
    ><h3
      ><a href="#TOC"
	>Первая программа</a
	></h3
      ><p
      >Для того, чтобы создать приложение для node.js, необходимо всего лишь создать новый файл с расширением '.js'. Например, можно создать файл 'hello_world.js' со следующим содержимым:</p
      ><pre class="sourceCode javascript"
      ><code
	>console.<span class="kw"
	  >log</span
	  >(<span class="st"
	  >'</span
	  ><span class="ch"
	  >Hello World'</span
	  >);<br
	   /></code
	></pre
      ><p
      >После того, как файл сохранен, его можно запустить на выполнение из терминала/консоли следующим образом:</p
      ><pre class="shell"
      ><code
	>$ node hello.js
Hello World
</code
	></pre
      ></div
    ><div id="hello-world-http-&#1089;&#1077;&#1088;&#1074;&#1077;&#1088;"
    ><h3
      ><a href="#TOC"
	>hello world http-сервер</a
	></h3
      ><p
      >В наше время вывод на терминал 'hello world' не сильно впечатляет. Необходимо идти дальше и написать программу, которая отдает 'hello world' по http. Для этого необходимо создать файл 'hello_http.js' и поместить в него следующий код:</p
      ><pre class="sourceCode javascript"
      ><code
	><span class="kw"
	  >var</span
	  > http = require(<span class="st"
	  >'</span
	  ><span class="ch"
	  >http'</span
	  >);<br
	   /><br
	   /><span class="kw"
	  >var</span
	  > server = http.createServer(<span class="kw"
	  >function</span
	  >(req, res) {<br
	   />&#160;&#160;res.writeHead(<span class="dv"
	  >200</span
	  >);<br
	   />&#160;&#160;res.end(<span class="st"
	  >'</span
	  ><span class="ch"
	  >Hello Http'</span
	  >);<br
	   />});<br
	   />server.listen(<span class="dv"
	  >8080</span
	  >);<br
	   /></code
	></pre
      ><p
      >Для того, чтобы запустить это приложение, необходимо выполнить в терминале/консоле:</p
      ><pre class="shell"
      ><code
	>$ node hello_http.js
</code
	></pre
      ><p
      >Первое, что бросается в глаза - это то, что эта прогарамма, в отличие от первой, не прекращается сразу. Это происходит в силу того, что node.js приложение будет всегда исполняться, пока не станет ясно, что никакие дальнейшие события не возможны. В этом случае запущенный http сервер - это источник событий, которые будут обеспечивать работу node.js приложения.</p
      ><p
      >Чтобы проверить работу сервера достаточно открыть новую закладку в web-браузере и перейти по следующему адресу: <a href="http://localhost:8080/"
	>http://localhost:8080/</a
	>. Как и ожидалось, ответом будет: 'Hello Http'.</p
      ><p
      >В качестве альтернативы, можно воспользоваться терминалом/консолью и используя <a href="http://ru.wikipedia.org/wiki/CURL"
	>curl</a
	> протестировать работу сервера:</p
      ><pre class="shell"
      ><code
	>$ curl localhost:8080
Hello Http
</code
	></pre
      ><p
      >Теперь необходимо по-ближе посмотреть на код созданной программы. В первой строке подключается <a href="http://nodejs.org/docs/v0.4.5/api/http.html"
	>http</a
	> модуль ядра и присваивается переменной <code
	>http</code
	>. О модульной системе будет рассказано более подробно в следующем разделе.</p
      ><p
      >В следующей строке создается переменная <code
	>server</code
	> которой присваивается результат вызова метода <a href="http://nodejs.org/docs/v0.4.5/api/http.html#http.createServer"
	>http.createServer</a
	>. Аргументом при вызове этого метода является <a href="http://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%BC%D1%8B%D0%BA%D0%B0%D0%BD%D0%B8%D0%B5_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)"
	>замыкание</a
	>, которое будет вызываться каждый раз, когда приходит http-запрос.</p
      ><p
      >И в конце вызывается метод <a href="http://nodejs.org/docs/v0.4.5/api/http.html#server.listen"
	>server.listen(8080)</a
	>, который указатывает node.js на каком порту требуется работа сервера. Если необходимо запустить сервер на 80-ом порту, то программу необходимо запускать с правами <a href="http://ru.wikipedia.org/wiki/Root_(%D1%81%D1%83%D0%BF%D0%B5%D1%80%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C)"
	>супер пользователя</a
	>.</p
      ><p
      >Далее, когда в браузере идет обращение к адресу <a href="http://localhost:8080/"
	>localhost:8080</a
	>, вызывается замыкание с параметрами <a href="http://nodejs.org/docs/v0.4.5/api/http.html#http.ServerRequest"
	>req</a
	> и <a href="http://nodejs.org/docs/v0.4.5/api/http.html#http.ServerResponse"
	>res</a
	>. Req - это поток, доступный для чтения, который содержит данные каждого http-запроса (например, подтверждение формы или загрузка файла). Res - это поток, доступный для записи, который используется для отправки данных обратно клиенту. В примере, отсылается заголовок 200 OK, а так же тело ответа 'Hello Http'.</p
      ></div
    ></div
  ><div id="&#1084;&#1086;&#1076;&#1091;&#1083;&#1100;&#1085;&#1072;&#1103;-&#1089;&#1080;&#1089;&#1090;&#1077;&#1084;&#1072;"
  ><h2
    ><a href="#TOC"
      >Модульная система</a
      ></h2
    ><p
    >Для организации программ в виде отдельных файлов, node.js предлагает к использованию модульную систему.</p
    ><p
    >Для демонстрации подхода создадим файл 'main.js' со следующим содержимым:</p
    ><pre class="sourceCode javascript"
    ><code
      ><span class="kw"
	>var</span
	> hello = require(<span class="st"
	>'</span
	><span class="ch"
	>./hello'</span
	>);<br
	 />hello.world();<br
	 /></code
      ></pre
    ><p
    >Не трудно догадаться, что <code
      >require('./hello')</code
      > используется для импорта данных из отдельного JavaScript файла. './' означает, что файл находится в той же директории, что и и сам файл 'main.js'. Так же следует обратить внимание, что не требуется указывать расширение файла, так как '.js' подставляется по умолчанию.</p
    ><p
    >Далее, необходимо создать файл 'hello.js' со следующим содержимым:</p
    ><pre class="sourceCode javascript"
    ><code
      >exports.world = <span class="kw"
	>function</span
	>() {<br
	 />&#160;&#160;console.<span class="kw"
	>log</span
	>(<span class="st"
	>'</span
	><span class="ch"
	>Hello World'</span
	>);<br
	 />}<br
	 /></code
      ></pre
    ><p
    >Тут следует обратить внимание на то, что происходит присваивание свойству 'world' объекта 'exports'. Таким образом объявляется, что модуль 'hello.js' экспортирует во вне функцию 'world'. Объект 'exports' доступен в любом модуле и возвращается при каждом вызове функции <code
      >require</code
      > при подключении модуля. При запуске 'main.js' вывод будет следующим:</p
    ><pre class="shell"
    ><code
      >$ node main.js
Hello World
</code
      ></pre
    ><p
    >Будет не лишним упомянуть, что зачастую объект 'exports' переопределяется следующим образом:</p
    ><pre class="sourceCode javascript"
    ><code
      >module.exports = <span class="kw"
	>function</span
	>() {<br
	 />&#160;&#160;<span class="co"
	>// ...</span
	><br
	 />}<br
	 /></code
      ></pre
    ><p
    >Как и ожидается, такое переопределение будет причиной того, что функция <code
      >require</code
      > будет возвращать функцию. Такой подход полезен при <a href="/felix/object_oriented_programming/"
      >объекто ориентированном программировании</a
      >, где каждый файл экспортирует конструктор одного класса.</p
    ><p
    >Следующая вещь, которую надо понимать при работе с модульной системой, это то, как система работает с вызовами 'require', которые не включают относительную подсказку о метоположении подключаемого файла. Например:</p
    ><pre class="sourceCode javascript"
    ><code
      ><span class="kw"
	>var</span
	> http = require(<span class="st"
	>'</span
	><span class="ch"
	>http'</span
	>);<br
	 /></code
      ></pre
    ><p
    >Первое, что сделает node.js - это определит, есть ли модуль ядра с именем http. Если есть, то вернет соответствующую директорию. Но что будет при работе с модулями не относящимися к ядру, как например 'mysql'?</p
    ><pre class="sourceCode javascript"
    ><code
      ><span class="kw"
	>var</span
	> mysql = require(<span class="st"
	>'</span
	><span class="ch"
	>mysql'</span
	>);<br
	 /></code
      ></pre
    ><p
    >В этом случае node.js будет искать в каждой директории, начиная с одного из текущих файлов, и проверять, есть ли директория с именем 'node_modules'. Если такая директория найдена, node.js начнет поиск в ней файла с именем 'mysql.js'. Если подходящих файлов не найдено и достигнут корень файловой системы ('/') node.js сдается и выбрасывает исключение.</p
    ><p
    >В настоящий момент node.js учитывает дополнительный изменяемый список альтернативных директорий для импорта. Список доступен через массив <code
      >require.paths</code
      >. Однако идет активное обсуждение на тему удаления этой возможности, так что лучше пока не использовать ее.</p
    ><p
    >И наконец, node.js учитывает файл 'index.js', в котором описывается главный файл импорта для директории. Таким образом, если встретится вызов <code
      >require('./foo')</code
      >, то node.js будет пробовать искать файлы и 'foo.js' и 'foo/index.js'.</p
    ></div
  ><div id="&#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077;-eventemitters"
  ><h2
    ><a href="#TOC"
      >Использование EventEmitters</a
      ></h2
    ><p
    >Node.js реализует <a href="http://ru.wikipedia.org/wiki/%D0%A8%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F"
      >шаблон проектирования</a
      > <a href="http://en.wikipedia.org/wiki/Observer_pattern"
      >наблюдатель</a
      > (<a href="http://ru.wikipedia.org/wiki/%D0%9D%D0%B0%D0%B1%D0%BB%D1%8E%D0%B4%D0%B0%D1%82%D0%B5%D0%BB%D1%8C_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)"
      >рус</a
      >) используя класс EventEmitter. Всегда, когда естЬ объект, который является источником событий, node.js наследует класс этого объекта от класса EventEmitter.</p
    ><p
    >Использовать EventEmitter и его наследников довольно просто. Необходимо лишь вызвать метод 'on()' у объекта, генерирующего события, и передать в качестве параметров имя события и функцию обратного вызова. Например:</p
    ><pre class="sourceCode javascript"
    ><code
      ><span class="kw"
	>var</span
	> <span class="dt"
	>data</span
	> = <span class="st"
	>'</span
	><span class="ch"
	>'</span
	>;<br
	 />req<br
	 />&#160;&#160;.on(<span class="st"
	>'</span
	><span class="ch"
	>data'</span
	>, <span class="kw"
	>function</span
	>(chunk) {<br
	 />&#160;&#160; &#160;data += chunk;<br
	 />&#160;&#160;})<br
	 />&#160;&#160;.on(<span class="st"
	>'</span
	><span class="ch"
	>end'</span
	>, <span class="kw"
	>function</span
	>() {<br
	 />&#160;&#160; &#160;console.<span class="kw"
	>log</span
	>(<span class="st"
	>'</span
	><span class="ch"
	>POST data: %s'</span
	>, <span class="dt"
	>data</span
	>);<br
	 />&#160;&#160;})<br
	 /></code
      ></pre
    ><p
    >Как видно, функция <a href="http://nodejs.org/docs/v0.4.5/api/all.html#emitter.on"
      >on()</a
      > возвращает ссылку на объект, которому она принадлежит, что позволяет связывать в цепочки вызовов несколько прослушивателей событий.</p
    ><p
    >Если интересует только первое возникновение события, то вместо <a href="http://nodejs.org/docs/v0.4.5/api/all.html#emitter.on"
      >on()</a
      > можно использовать функцию <a href="http://nodejs.org/docs/v0.4.5/api/all.html#emitter.once"
      >once()</a
      >.</p
    ><p
    >Наконец, можно удалить возможность прослушивания событий с помощью функции <a href="http://nodejs.org/docs/v0.4.5/api/all.html#emitter.removeListener"
      >removeListener</a
      >. Следует обратить внимание, что аргументами в этой функции являются ссылки на функции обратного вызова, которые необходимо удалить, а не имена событий:</p
    ><pre class="sourceCode javascript"
    ><code
      ><span class="kw"
	>var</span
	> onData = <span class="kw"
	>function</span
	>(chunk) {<br
	 />&#160;&#160;console.<span class="kw"
	>log</span
	>(chunk);<br
	 />&#160;&#160;req.removeListener(onData);<br
	 />}<br
	 /><br
	 />req.on(<span class="st"
	>'</span
	><span class="ch"
	>data'</span
	>, onData);<br
	 /></code
      ></pre
    ><p
    >Этот пример идентичен случаю использования метода <a href="http://nodejs.org/docs/v0.4.5/api/all.html#emitter.once"
      >once()</a
      >.</p
    ></div
  ><div id="&#1095;&#1090;&#1086;-&#1076;&#1072;&#1083;&#1100;&#1096;&#1077;"
  ><h2
    ><a href="#TOC"
      >Что дальше ?</a
      ></h2
    ><p
    >Теперь у вас есть базовые знания о node.js и сейчас лучше попробовать написать самостоятельно несколько небольших программ. Лучшее место для начала - это <a href="http://nodejs.org/docs/v0.4.5/api/"
      >документация по API node.js</a
      >.</p
    ></div
  ><div id="&#1086;&#1090;&#1083;&#1072;&#1076;&#1082;&#1072;-&#1087;&#1088;&#1080;&#1083;&#1086;&#1078;&#1077;&#1085;&#1080;&#1081;-node.js"
  ><h2
    ><a href="#TOC"
      >Отладка приложений node.js</a
      ></h2
    ><p
    >Существует много способов отладки node.js приложений. Лично я предпочитаю отлаживаться как можно меньше и следовать максимально точно <a href="test_driven_development.html"
      >руководству по разработке через тестирование</a
      >.</p
    ><p
    >Однако, если случится ситуация, когда будет необходимо локализовать необычную ошибку в приложении, можно воспользоваться одним из указанных способов.</p
    ><div id="&#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077;-console.log"
    ><h3
      ><a href="#TOC"
	>Использование console.log()</a
	></h3
      ><p
      >Самый просто способ понять проблему - это исследовать объекты с помощью console.log(). Объекты можно передавать в качестве параметров:</p
      ><pre class="sourceCode javascript"
      ><code
	><span class="kw"
	  >var</span
	  > foo = {bar: <span class="st"
	  >'</span
	  ><span class="ch"
	  >foobar'</span
	  >};<br
	   />console.<span class="kw"
	  >log</span
	  >(foo);<br
	   /></code
	></pre
      ><p
      >Или же можно использовать sprintf-подобные возможности для форматирования отладочных сообщений:</p
      ><pre class="sourceCode javascript"
      ><code
	><span class="kw"
	  >var</span
	  > foo = {bar: <span class="st"
	  >'</span
	  ><span class="ch"
	  >foobar'</span
	  >};<br
	   />console.<span class="kw"
	  >log</span
	  >(<span class="st"
	  >'</span
	  ><span class="ch"
	  >Hello %s, this is my object: %j'</span
	  >, <span class="st"
	  >'</span
	  ><span class="ch"
	  >World'</span
	  >, foo);<br
	   /></code
	></pre
      ></div
    ><div id="&#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077;-&#1086;&#1090;&#1083;&#1072;&#1076;&#1095;&#1080;&#1082;&#1072;-node.js"
    ><h3
      ><a href="#TOC"
	>Использование отладчика node.js</a
	></h3
      ><p
      >Если console.log() чем-то не устраивает или есть вероятность, что текущая проблема может быть решена быстрее с помощью точек останова, то наиболее подходящим вариантом будет встроенный node.js отладчик. Отладчик вызывается легко:</p
      ><pre class="shell"
      ><code
	>$ node.js debug my_file.js
</code
	></pre
      ><p
      ><em
	>Work in progress, please come back later ...</em
	></p
      ></div
    ><div id="&#1080;&#1089;&#1087;&#1086;&#1083;&#1100;&#1079;&#1086;&#1074;&#1072;&#1085;&#1080;&#1077;-webkit-inspector"
    ><h3
      ><a href="#TOC"
	>Использование WebKit Inspector</a
	></h3
      ><p
      ><em
	>Work in progress, please come back later ...</em
	></p
      ></div
    ></div
  ><div id="&#1092;&#1088;&#1077;&#1081;&#1084;&#1074;&#1086;&#1088;&#1082;&#1080;"
  ><h2
    ><a href="#TOC"
      >Фреймворки</a
      ></h2
    ><p
    >Новичку с node.js вряд ли захочется изобретать колесо, когда потребуется разобрать POST-запрос, маршрутизировать URL или сформировать представление. В этих случаях с большой долей вероятности захочется использовать один из популярных веб-фреймворков. Данный раздел дает беглый обзор основных их них и мое отношение к ним.</p
    ><div id="express"
    ><h3
      ><a href="#TOC"
	>Express</a
	></h3
      ><p
      >На текущий момент <a href="http://expressjs.com/"
	>express</a
	> - наиболее подходящий фреймворк для большинства node.js разработчиков. Он относительно зрелый и включает <a href="https://github.com/senchalabs/connect"
	>connect</a
	> (тонкий каркас) средний слой. Поддерживает такие возможности, как маршрутизация, конфигурация, шаблонный движок, разбор POST запросов и многое другое.</p
      ><p
      >В то время, как express уже достаточно цельный фреймворк, он используется в гораздо меньших масштабах по сравнению с такими аналогами, как Rails, CakePHP или Django. Express наболее сопоставим с таким инструментом, как Sinatra и, к сожалению, пока не сделал больших усилий для того, чтобы уйти от Ruby корней в сторону чего-то более естественного для JavaScript. Так или иначе, его использование гораздо проще и быстрее, чем создание своего собственного фреймворка и в настоящий момент это наиболее достойный выбор.</p
      ></div
    ><div id="fab.js"
    ><h3
      ><a href="#TOC"
	>fab.js</a
	></h3
      ><p
      >Думаете, что знаете JavaScript? Подумайте еще раз. Разработчики <a href="http://fabjs.org/"
	>fab.js</a
	>, вдохновленные цепочками jQuery, выбрали очень необычный подход. Каждая функция возвращает функцию, устраняя необходмиость в именах методов вообще. Тем самым формируется код, напоминающий Lisp.</p
      ><p
      >На данный момент, я не считаю, что fab.js готов к промышленной разработке. Но если вы все еще изучаете мир node.js, то вам абсолютно необходимо эту библиотеку как минимум один раз. Если альтернативы нет, то fab.js откроет мир, в котором JavaScript не копирует решения Ruby, Python или PHP при создании веб-фреймворков и может развиваться уникальным образом.</p
      ></div
    ></div
  ><div id="&#1093;&#1086;&#1089;&#1090;&#1080;&#1085;&#1075;-&#1080;-deployment"
  ><h2
    ><a href="#TOC"
      >Хостинг и Deployment</a
      ></h2
    ><div id="&#1073;&#1099;&#1089;&#1090;&#1088;&#1099;&#1081;-deployment"
    ><h3
      ><a href="#TOC"
	>Быстрый Deployment</a
	></h3
      ><p
      >Если вы написали первое приложение для node.js, то наверняка хотите запустить его как можно быстрее. Вот как это можно сделать:</p
      ><ol style="list-style-type: decimal;"
      ><li
	><p
	  >Скопируйте программу на сервер, где приложение будет запущено. Если используется git, то это просто означает, что необходимо сделать клон репозитория из стороннего сервера или сервиса (например <a href="http://github.com/"
	    >GitHub</a
	    >).</p
	  ></li
	><li
	><p
	  >Предполагая, что проект содержит файл 'server.js', необходимо перейти в директорию, в которой содержится этот файл и выполнить:</p
	  ></li
	></ol
      ><pre class="shell"
      ><code
	>$ screen
$ node server.js
</code
	></pre
      ><p
      >Этот пример запускает 'server.js' внутри screen-сессии. <a href="http://ru.wikipedia.org/wiki/GNU_Screen"
	>Screen</a
	> - это утилита, предоставляющая возможность сохранять состояние shell'a даже в случае, если закрыт терминал/консоль, через который происходило соединение с сервером.</p
      ><p
      >Таким образом, теперь можно безопасно закрыть терминал/консоль (из screen выходить через control-a + d), а 'server.js' при этом продолжит работать в screen-сессии. Если есть необходимость проверить работу приложения, можно снова соединиться с сервером и выполнить:</p
      ><pre class="shell"
      ><code
	>$ screen -r
</code
	></pre
      ><p
      >Эта команда восстановит соединение с shell'ом, в котором в фоне работает 'server.js'.</p
      ><p
      >Однако, этот подход рекомендуется только для экспериментального deployment'a. Так как, если в приложении произойдет сбой, screen не попытается перезапустить его. Соответственно, для production окружения этот метод котегорически не рекомендуется.</p
      ></div
    ><div id="joyent-no.de"
    ><h3
      ><a href="#TOC"
	>Joyent no.de</a
	></h3
      ><p
      ><em
	>Work in progress, please come back later ...</em
	></p
      ></div
    ></div
  ></div
>

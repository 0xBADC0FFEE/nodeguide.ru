# Руководство по стилю кода в Node.js от Felix'a

В настоящий момент не существует официального документа, который бы
регламентировал стиль кода в node.js приложениях. Это руководство - моя 
попытка донести до читателя набор подходов, позволяющих создавать
прекрасное и целостное ПО.

Руководство предполагает, что читатель работает исключительно в node.js.
Если предполагается запуск кода в браузере или каком-либо другом окружении,
то некоторые пукнты текста можно игнорировать.

Так же следует обратить внимание, что и node.js, и многие пакеты для него,
имеют свои собственные соглашения о стиле кода, которые не всегда совпадают.
Таким образом, если Вы собираетесь вносить клад в код какого-либо пакета, то
следуйте соглашению о стиле этого пакета.

## Табуляция vs Пробелы

Начнем с религиозных проблем. Наш [великодушный диктатор][ryah] выбрал при 
разработке ядра node.js отступ в 2 пробела. Таким образом, было бы хорошо,
если бы вы так же последовали его примеру.

[ryah]: community.html#ryan-dahl

## Точка с запятой

Есть [мятежные силы][isaac], которые пытаются украсть у вас точки с запятой.
Но не совершайте ошибок! Наша традиционная культура все еще [живет][hnsemicolons].
Так что следуйте за сообществом и пользуйтесь точками с запятыми!

[isaac]: community.html#isaac-schlueter
[hnsemicolons]: http://news.ycombinator.com/item?id=1547647

## Редакторы

Вы можете использовать любой редактор. Однако было бы удобно, чтобы он умел
подсвечивать синтаксис JavaScript'a и выполнять в среде node.js редактируемый
файл. [Vim][vim], конечно, не поможет вам впечатлить девушку, но зато он угодит
нашему [великодушному пожизненному диктатору][bdfl] и ваш дедушка его тоже одобрит.

Я пишу этот документ в Notes на моем iPad'e, но это все потому, что я сейчас 
нахожусь на пляже в Тайланде. Так что, вполне вероятно, что ваше собственное
рабочее окружение повлияет на ваш выбор редактора.

[vim]: http://www.vim.org/
[bdfl]: http://en.wikipedia.org/wiki/BDFL

## Концевые пробелы

Точно так же, как вы чистите зубы после еды, вы должны подчищать конечные 
пробелы в ваших JavaScript файлах перед тем, как сделать коммит. Иначе гнилой
запах небрежности и пренебрежения разгонить в итоге авторов и/или коллег.

## Длинна строки

Следует ограничивать строки 80-ю символами. Да, экраны за последние несколько
лет стали больше, но ваш мозг не стал. Используйте дополнительное место для 
разбиения экрана. Ваш же редактор это позволяет, не так ли?

## Кавычки

Используйте одиночные кавычки везде, кроме случаев редактирования JSON.

*Хорошо:*

~~~ {.javascript}
var foo = 'bar';
~~~

*Плохо:*

~~~ {.javascript}
var foo = "bar";
~~~

## Фигурные скобки

Располагайте открывающую скобку на той же линии, что и выражение.

*Хорошо:*

~~~ {.javascript}
if (true) {
  console.log('winning');
}
~~~

*Плохо:*

~~~ {.javascript}
if (true)
{
  console.log('losing');
}
~~~

Так же обратите внимание на использование пробела перед и после условного
выражения.

## Объявление переменных

Объявляйте по одной переменной с каждым ключевым словом var. Такой подход
облегчает переупорядочивание строк. Не обращайте внимания на [Crockford]
[crockfordconvention]'a по этому поводу, и размещайте объявления там, где 
они имеют смысл.

*Хорошо:*

~~~ {.javascript}
var keys = ['foo', 'bar'];
var values = [23, 42];

var object = {};
while (items.length) {
  var key = keys.pop();
  object[key] = values.pop();
}
~~~

*Плохо:*

~~~ {.javascript}
var keys = ['foo', 'bar'],
    values = [23, 42],
    object = {},
    key;

while (items.length) {
  key = keys.pop();
  object[key] = values.pop();
}
~~~

[crockfordconvention]: http://javascript.crockford.com/code.html

## Имена переменных и свойств

Переменные и свойства должны использовать [нижний верблюжий регистр]
[camelcase] / [рус][camelcaseru]. Кроме того, они должны быть наглядными.
Одиночных символов и необычных аббревиатур следует избегать.

*Хорошо:*

~~~ {.javascript}
var adminUser = db.query('SELECT * FROM users ...');
~~~

*Плохо:*

~~~ {.javascript}
var admin_user = d.query('SELECT * FROM users ...');
~~~

[camelcase]: http://en.wikipedia.org/wiki/camelCase#Variations_and_synonyms
[camelcaseru]: http://ru.wikipedia.org/wiki/CamelCase

## Имена классов

Имена классов должны использовать [верхний верблюжий регистр][camelcase].

*Хорошо:*

~~~ {.javascript}
function BankAccount() {
}
~~~

*Плохо:*

~~~ {.javascript}
function bank_Account() {
}
~~~

## Константы

Константы должны объявляться как обычные переменные или статические свойства
классов. Все буквы должны быть в верхнем регистре.

Node.js / V8 поддерживает расширение [const][const] от mozilla, но, к сожалению,
оно не применимо к членам класса, равно как и часть любого стандарта ECMA.

*Хорошо:*

~~~ {.javascript}
var SECOND = 1 * 1000;

function File() {
}
File.FULL_PERMISSIONS = 0777;
~~~

*Плохо:*

~~~ {.javascript}
const SECOND = 1 * 1000;

function File() {
}
File.fullPermissions = 0777; 
~~~

[const]: https://developer.mozilla.org/en/JavaScript/Reference/Statements/const

## Создание Объекта / Массива

Используйте завершающие запятые и *короткие* обявления на одной строке. 
Ключи помещайте в кавычки только тогда, когда пожалуется интерпретатор. 

*Хорошо:*

~~~ {.javascript}
var a = ['hello', 'world'];
var b = {
  good: 'code',
  'is generally': 'pretty',
};
~~~

*Плохо:*

~~~ {.javascript}
var a = [
  'hello', 'world'
];
var b = {"good": 'code'
        , is generally: 'pretty'
        };
~~~

## Оператор равенства


Программирование - это вам не запоминание [глупых правил][comparisonoperators].
Используйте тройной оператор равенства, так как только он будет работать так,
как ожидается.

*Хорошо:*

~~~ {.javascript}
var a = 0;
if (a === '') {
  console.log('winning');
}

~~~

*Плохо:*

~~~ {.javascript}
var a = 0;
if (a == '') {
  console.log('losing');
}
~~~

[comparisonoperators]: https://developer.mozilla.org/en/JavaScript/Reference/Operators/Comparison_Operators

## Расширение прототипов

Не расширяйте прототипы всех подряд объектов, особенно встроенных. В аду есть
специальное место, в котором вас будут ждать, если вы не будете следовать этому
правилу.

*Хорошо:*

~~~ {.javascript}
var a = [];
if (!a.length) {
  console.log('winning');
}
~~~

*Плохо:*

~~~ {.javascript}
Array.prototype.empty = function() {
  return !this.length;
}

var a = [];
if (a.empty()) {
  console.log('losing');
}
~~~

## Условия

Все нетривиальные условия должны присваиваться переменной.

*Хорошо:*

~~~ {.javascript}
var isAuthorized = (user.isAdmin() || user.isModerator());
if (isAuthorized) {
  console.log('winning');
}
~~~

*Плохо:*

~~~ {.javascript}
if (user.isAdmin() || user.isModerator()) {
  console.log('losing');
}
~~~

## Размер функций

Функции должны быть короткими. Хорошая функция должна помещаться на слайд,
который будет хорошо читаться людми, сидящими на последнем ряду в большой
комнате.

## Оператор return

Возвращайте значение из функции как можно раньше. Тем самым будет исключаться
большая вложенность if-else конструкций.

*Хорошо:*

~~~ {.javascript}
function isPercentage(val) {
  if (val < 0) {
    return false;
  }

  if (val > 100) {
    return false;
  }

  return true;
}
~~~

*Плохо:*

~~~ {.javascript}
function isPercentage(val) {
  if (val >= 0) {
    if (val < 100) {
      return true;
    } else {
      return false;
    }
  } else {
    return false;
  }
}
~~~

Или для этого конкретного примера этот подход так же применим:

~~~ {.javascript}
function isPercentage(val) {
  var isInRange = (val >= 0 && val <= 100);
  return isInRange;
}
~~~

## Именованные замыкания

Не бойтесь давать замыканиям имена. Это показывает, что вы заботитесь о них.
Результатом этой заботы будет более полная трассировка стека:

*Хорошо:*

~~~ {.javascript}
req.on('end', function onEnd() {
  console.log('winning');
});
~~~

*Плохо:*

~~~ {.javascript}
req.on('end', function() {
  console.log('losing');
});
~~~

## Вложенные замыкания

Не используйте вложенные замыкания. Иначе ваш код превратится в кашу

*Хорошо:*

~~~ {.javascript}
setTimeout(function() {
  client.connect(afterConnect);
}, 1000);

function afterConnect() {
  console.log('winning');
}
~~~

*Плохо:*

~~~ {.javascript}
setTimeout(function() {
  client.connect(function() {
    console.log('losing');
  });
}, 1000);
~~~

## Функции обратного вызова (callbacks)

Так как node.js прежде всего сосредоточен на неблокирующем вводе/выводе, то
функции в основном возвращают свой результат используя callback'и. В ядре 
node.js принято соглашение, что первый параметр любого callback'а всегда 
является необязательным объектом-ошибкой (error object).

Вам так же следует пользоваться этим подходом для ваших callback'ов.

## Object.freeze, Object.preventExtensions, Object.seal, with, eval

Абсолютное безумие, которое, вероятно, никогда вами не будет использовано.
Держитесь от этого дела подальше.

## Getter'ы и setter'ы

Не используйте setter'ы. У людей, которые будут пытаться использовать ваш
код, они обязательно вызовут массу проблем.

Getter'ы же - напротив, можно совершенно спокойно использовать в своем коде.
Так как они являются чистыми функциями и свободны от [побочных эффектов]
[sideeffect] ([рус][sideeffectru]). Типовым примером является предоставление
свойтсва длины для класса коллекции.

[sideeffect]: http://en.wikipedia.org/wiki/Side_effect_(computer_science) 
[sideeffectru]: http://ru.wikipedia.org/wiki/Побочный_эффект_(программирование) 

## EventEmitter'ы

Node.js включает в себя среди прочего простой класс EventEmitter, который 
может быть подключен из модуля 'events':

~~~ {.javascript}
var EventEmitter = require('events').EventEmitter;
~~~

При создании классов, которые должны поддерживать события, их обычно наследуют
от этого класса EventEmitter. В основном это простая реализация [шаблона 
Observer][Observer pattern] ([рус][observerpatternru])

[Observer pattern]: http://en.wikipedia.org/wiki/Observer_pattern
[observerpatternru]: http://ru.wikipedia.org/wiki/Наблюдатель_(шаблон_проектирования) 

Однако, я настоятельно не рекомендую слушать события объекта изнутри самого 
объекта. Это не естественно: слушать самого себя. Зачастую, это ведет к
нежелательному открытию деталей реализации и усложнению сопровождения кода.

## Наследование / Объектно-ориентированное програмиирование

Наследование и объектно-ориентированное програмиирование являются обширными
темами. Если вы интересуетесь этими популярными подходами программирования,
то почитатйте, пожалуйста, мое [Руководство по объектно-ориентированному 
программированию][Object oriented programming guide].

[Object oriented programming guide]: object_oriented_programming.html


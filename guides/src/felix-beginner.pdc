# Руководство для начинающих по Node.js от Felix'a

В интернете сейчас много информации про node.js, но учитывая скорость, с которой
идет разработка, достаточно тяжело найти актуальную информацию о том, как начать 
с ним работать. Это руководство ставит перед собой именно такую цель - оставаться 
актуальным для последней стабильной версии node.js.

Сейчас руководство соответствует последним изменениям в версии node 0.4.x., которая
является стабильной веткой.

## Изучение JavaScript

Предполагается, что читатель уже знаком с JavaScript. Если нет, то можно начать с чтения 
[Eloquent JavaScript][eloquentjs], свободно распространяемой книги от [Marijn Haverbeke][marijn].

[eloquentjs]: http://eloquentjavascript.net/
[marijn]: http://twitter.com/marijnjh

## Hello World

Этот пример продемонстрирует как установить node.js, включая создание простого
http сервера.

### Установка node.js

Прежде всего: для того, чтобы использовать node.js необходимо иметь под рукой 
работающую \*nix - подобную операционную систему. Рекомендуется Linux или OSX, 
но так же могут подойти FreeBSD или cygwin (под windows). В настоящее время ведутся 
работы над портированием node.js под windows, но пока они не доведены до стабильного
состояния.

Наиболее распространенный подход для установки node.js является его компиляция 
из исходных кодов. Существуют так же различные пакеты для пакетных менеджеров, 
но учитывая то, как часто они обновляются и то, как их обновление может различаться,
рекомендуется установка из исходных кодов.

Получить последние исходные коды можно на сайте [nodejs.org][nodejs]. Для получения
и установки версии 0.4.5 необходимо выполнить следующие команды:

[nodejs]: http://nodejs.org/

~~~ {.shell}
$ wget http://nodejs.org/dist/node-v0.4.5.tar.gz
$ tar -xzf node-v0.4.5.tar.gz
$ cd node-v0.4.5.tar.gz
$ ./configure
$ sudo make install
~~~

Node.js не имеет внешних зависимостей, кроме python, который используется при сборке.
В OSX необходимо установить XCode перед началом установки. В Ubuntu же необходимо 
выполнить:

~~~ {.shell}
$ apt-get -y install build-essential
~~~

### Интерактивная оболочка node.js

Если установка прошла без ошибок, то станет доступен вызов интерактивной оболочки
node.js, например:

~~~ {.shell}
$ node
> console.log('Hello World');
Hello World
~~~

Интерактивная оболочка (или [REPL][REPL], [REPL-ru][REPLRU]) удобна для тестирования 
простых однострочных примеров. Кроме того, она может быть [внедрена][repldocs] в любое 
node.js приложение. Для того, чтобы выйти из интерактивной оболочки, необходимо просто 
нажать Ctrl + C.

Оболочка (REPL) обладает множеством удобств, основным среди которых является автодополнение.

[repldocs]: http://nodejs.org/docs/v0.4.5/api/repl.html#repl.start
[REPL]: http://en.wikipedia.org/wiki/REPL
[REPLRU]: http://ru.wikipedia.org/wiki/REPL

### Первая программа

Для того, чтобы создать приложение для node.js, необходимо всего лишь создать
новый файл с расширением '.js'. Например, можно создать файл 'hello_world.js'
со следующим содержимым:

~~~ {.javascript}
console.log('Hello World');
~~~

После того, как файл сохранен, его можно запустить на выполнение из терминала/консоли
следующим образом:

~~~ {.shell}
$ node hello.js
Hello World
~~~

### hello world http-сервер

В наше время вывод на терминал 'hello world' не сильно впечатляет. Необходимо идти 
дальше и написать программу, которая отдает 'hello world' по http. Для этого необходимо 
создать файл 'hello_http.js' и поместить в него следующий код:

~~~ {.javascript}
var http = require('http');

var server = http.createServer(function(req, res) {
  res.writeHead(200);
  res.end('Hello Http');
});
server.listen(8080);
~~~

Для того, чтобы запустить это приложение, необходимо выполнить в терминале/консоле:

~~~ {.shell}
$ node hello_http.js
~~~

Первое, что бросается в глаза - это то, что эта прогарамма, в отличие от первой,
не прекращается сразу. Это происходит в силу того, что node.js приложение будет всегда 
исполняться, пока не станет ясно, что никакие дальнейшие события не возможны. В этом 
случае запущенный http сервер - это источник событий, которые будут обеспечивать 
работу node.js приложения.

Чтобы проверить работу сервера достаточно открыть новую закладку в web-браузере и 
перейти по следующему адресу: [http://localhost:8080/][localhost]. Как и
ожидалось, ответом будет: 'Hello Http'.

В качестве альтернативы, можно воспользоваться терминалом/консолью и используя [curl][curl] 
протестировать работу сервера:

[curl]: http://ru.wikipedia.org/wiki/CURL

~~~ {.shell}
$ curl localhost:8080
Hello Http
~~~

Теперь необходимо по-ближе посмотреть на код созданной программы. В первой строке
подключается [http][httpdoc] модуль ядра и присваивается переменной `http`. О 
модульной системе будет рассказано более подробно в следующем разделе.

В следующей строке создается переменная `server` которой присваивается результат
вызова метода [http.createServer][createServerdoc]. Аргументом при вызове этого 
метода является [замыкание][closure], которое будет вызываться каждый раз, когда 
приходит http-запрос.

И в конце вызывается метод [server.listen(8080)][listendoc], который указатывает node.js
на каком порту требуется работа сервера. Если необходимо запустить сервер на 80-ом 
порту, то программу необходимо запускать с правами [супер пользователя][rootdoc].

[httpdoc]: http://nodejs.org/docs/v0.4.5/api/http.html
[createServerdoc]: http://nodejs.org/docs/v0.4.5/api/http.html#http.createServer
[listendoc]: http://nodejs.org/docs/v0.4.5/api/http.html#server.listen
[closure]: http://ru.wikipedia.org/wiki/Замыкание_(программирование) 
[rootdoc]: http://ru.wikipedia.org/wiki/Root_(суперпользователь) 

Далее, когда в браузере идет обращение к адресу [localhost:8080][localhost], 
вызывается замыкание с параметрами [req][reqdoc] и [res][resdoc]. Req - это поток,
доступный для чтения, который содержит данные каждого http-запроса (например, 
подтверждение формы или загрузка файла). Res - это поток, доступный для записи,
который используется для отправки данных обратно клиенту. В примере, отсылается 
заголовок 200 OK, а так же тело ответа 'Hello Http'.

[localhost]: http://localhost:8080/
[reqdoc]: http://nodejs.org/docs/v0.4.5/api/http.html#http.ServerRequest
[resdoc]: http://nodejs.org/docs/v0.4.5/api/http.html#http.ServerResponse

## Модульная система

Для организации программ в виде отдельных файлов, node.js предлагает к использованию
модульную систему.

Для демонстрации подхода создадим файл 'main.js' со следующим содержимым:

~~~ {.javascript}
var hello = require('./hello');
hello.world();
~~~

Не трудно догадаться, что `require('./hello')` используется для импорта данных из
отдельного JavaScript файла. './' означает, что файл находится в той же директории,
что и и сам файл 'main.js'. Так же следует обратить внимание, что не требуется 
указывать расширение файла, так как '.js' подставляется по умолчанию.

Далее, необходимо создать файл 'hello.js' со следующим содержимым:

~~~ {.javascript}
exports.world = function() {
  console.log('Hello World');
}
~~~

Тут следует обратить внимание на то, что происходит присваивание свойству 'world'
объекта 'exports'. Таким образом объявляется, что модуль 'hello.js' экспортирует 
во вне функцию 'world'. Объект 'exports' доступен в любом модуле и возвращается при 
каждом вызове функции `require` при подключении модуля. При запуске 'main.js'
вывод будет следующим:

~~~ {.shell}
$ node main.js
Hello World
~~~

Будет не лишним упомянуть, что зачастую объект 'exports' переопределяется следующим 
образом:

~~~ {.javascript}
module.exports = function() {
  // ...
}
~~~

Как и ожидается, такое переопределение будет причиной того, что функция `require`
будет возвращать функцию. Такой подход полезен при [объекто ориентированном программировании][oopguide],
где каждый файл экспортирует конструктор одного класса.

[oopguide]: /felix/object_oriented_programming/

Следующая вещь, которую надо понимать при работе с модульной системой, это то, 
как система работает с вызовами 'require', которые не включают относительную 
подсказку о метоположении подключаемого файла. Например:

~~~ {.javascript}
var http = require('http');
~~~

Первое, что сделает node.js - это определит, есть ли модуль ядра с именем http.
Если есть, то вернет соответствующую директорию. Но что будет при работе с модулями
не относящимися к ядру, как например 'mysql'?

~~~ {.javascript}
var mysql = require('mysql');
~~~

В этом случае node.js будет искать в каждой директории, начиная с одного из текущих
файлов, и проверять, есть ли директория с именем 'node_modules'. Если такая директория
найдена, node.js начнет поиск в ней файла с именем 'mysql.js'. Если подходящих файлов 
не найдено и достигнут корень файловой системы ('/') node.js сдается и выбрасывает
исключение.

В настоящий момент node.js учитывает дополнительный изменяемый список альтернативных
директорий для импорта. Список доступен через массив `require.paths`. Однако идет
активное обсуждение на тему удаления этой возможности, так что лучше пока не 
использовать ее.

И наконец, node.js учитывает файл 'index.js', в котором описывается главный
файл импорта для директории. Таким образом, если встретится вызов `require('./foo')`,
то node.js будет пробовать искать файлы и 'foo.js' и 'foo/index.js'.
